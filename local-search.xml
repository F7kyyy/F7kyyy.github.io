<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>云计算作业2</title>
    <link href="/2022/03/19/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/"/>
    <url>/2022/03/19/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/</url>
    
    <content type="html"><![CDATA[<h2 id="列举威胁作用者有哪些并简要说明">1.列举威胁作用者有哪些，并简要说明</h2><p>威胁作用者是引发威胁的实体，因为与它能够实施攻击。云安全威胁可能来自内部也可以来自外部，可能来自于软件程序。相对于漏洞、威胁和风险以及安全策略和安全机制建立起来的保护措施而言，威胁作用者所承担的角色，如下图所示：</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203191834094.png" alt="image-20220319183403033" style="zoom: 50%;" /></p><ul><li><p><strong>匿名攻击者</strong>匿名攻击者是云中没有权限、不被信任的云服务用户，它通常是一个外部软件程序，通过公网发动网络攻击。当匿名攻击者对安全策略和防护所致有限时，这会抑制它们形成有效攻击的能力。因此，匿名攻击者往往诉诸绕过账号或窃取用户证书的手段，同时使用能够确保匿名性或需要大量资源才能被检举的方法。</p></li><li><p><strong>恶意服务作用者</strong>恶意服务作用者能截取并转发云内的网络流量。它通常是带有被损害的或恶意逻辑的服务代理或伪装成服务代理的程序，也有可能是能够远程截取并破坏消息内容的外部程序。</p></li><li><p><strong>授信的攻击者</strong>授信的攻击者与同意云环境中的云用户共享IT资源，试图利用合法的证书来把云提供者以及它们共享IT资源的云租户作为攻击目标。不同匿名攻击者（它们是非授权的），授信的攻击者通常滥用合法的证书或通过挪用敏感和保密的信息，在云的信任边界内部发动攻击。</p></li><li><p><strong>恶意的内部人员</strong>恶意的内部人员是人为的威胁作用者，它们的行为代表云提供者或者与之有关。它们通常是现任或前任雇员，或是能够访问云提供者资源范围的第三方。这种类型的威胁作用者会带来极大的破坏可能性，因为恶意的内部人员可能拥有访问云用户IT资源的管理特权。</p></li></ul><h2 id="列举云安全威胁有哪些并简要说明">2.列举云安全威胁有哪些，并简要说明</h2><p>云安全威胁可能来自内部也可以来自外部，可能来自于人也可能来自于软件程序。</p><ul><li><p><strong>流量窃听</strong></p><p>流量窃听是指当数据在传输到云中或在云内部传输时（通常是从云用户到云提供者）被恶意的服务作用者被动地截获，用于非法的信息收集之目的，这种攻击的目的就是直接破坏数据的保密性，可能也破坏了云用户和云提供者之间关系的保密性。由于这种攻击被动的本质，这种攻击更容易长时间进行而不被发现。</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203191837611.png" alt="image-20220319183744550" style="zoom:67%;" /></p></li><li><p><strong>恶意媒介</strong></p><p>恶意媒介威胁是指消息被恶意服务作用者截获并且被篡改，因此可能会被破坏消息的保密性和完整性。它还有可能在把消息转发到目的地之前插入有害的数据。</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203191838726.png" alt="image-20220319183843688" style="zoom:67%;" /></p></li><li><p><strong>拒绝服务</strong></p><p>拒绝服务（Dos）攻击的目标是使IT资源过载至无法正确运行。这种形式的攻击通过是以以下方式之一发起的：</p><ul><li><p>云服务上的负载由于伪造的消息或重复的通信请求不正常地增加。</p></li><li><p>网络流量过载，降低了响应性，性能下降。</p></li><li><p>发出多个云服务请求，每个请求都设计成消耗过量的内存和处理资源。</p></li></ul><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203191840953.png" alt="image-20220319184022880" style="zoom:67%;" /></p></li><li><p><strong>授权不足</strong></p><p>授权不足攻击是指错误地授予攻击者访问权限或是授权太宽泛，导致攻击者能够访问到本应该受到保护的IT资源。通常结果就是攻击者获得了对某些IT资源的直接访问的权利，这些资源实现的时候是假设只能是授信的用户程序才能访问的。这种攻击的一种变种称为弱认证，如果用弱密码或共享来保持IT资源就可能导致这种攻击</p></li><li><p><strong>虚拟化攻击</strong></p><p>虚拟化攻击利用的是虚拟化环境中的漏洞，获得了对底层物理硬件未被授权的访问</p></li><li><p><strong>信任边界重叠</strong></p><p>重叠的信任边界潜藏了一种威胁，攻击者可以利用多个云用户共享的、基于云的IT资源</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云计算</tag>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fluid主题优化</title>
    <link href="/2022/03/17/fluid%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
    <url>/2022/03/17/fluid%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>虽然fluid主题已经非常好看了，但我依旧可以通过一些简单的操作，让你的博客更加易用（更花里胡哨和装逼）<spanclass="github-emoji" data-alias="smile" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><h2 id="fluid-页脚增加网站运行时长">1. Fluid 页脚增加网站运行时长</h2><p>主题预览网站中有了很详细的介绍，这里就不在重复了</p><p><ahref="https://hexo.fluid-dev.com/posts/fluid-footer-custom/">配置链接</a>，效果如下：</p><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203172342237.png"alt="image-20220317234230202" /><figcaption aria-hidden="true">image-20220317234230202</figcaption></figure><h2 id="markdown-使用emoji">2. markdown 使用emoji</h2><p>默认不支持输入emoji表情，我们可以通过hexo-filter-emoji插件实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-filter-emoji<br></code></pre></td></tr></table></figure><p>之后在hexo配置文件，_config.html中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">## hexo-filter-emoji</span><br><span class="hljs-attr">emoji:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">className:</span> <span class="hljs-string">github-emoji</span><br>  <span class="hljs-attr">styles:</span><br>  <span class="hljs-attr">customEmojis:</span><br></code></pre></td></tr></table></figure><p>效果如下<span class="github-emoji" data-alias="thumbsup" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8">👍</span>:</p><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203172346789.png"alt="image-20220317234604763" /><figcaption aria-hidden="true">image-20220317234604763</figcaption></figure><h2 id="使用tidio进行实时交流">3. 使用Tidio进行实时交流</h2><p>Tidio是一个客服服务平台，可以在blog中实现LiveChat,存在网页端和移动端，可以及时回复消息，同时免费功能足够我们使用，效果如下：</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203191703130.png" alt="image-20220319170332006" style="zoom:50%;" /></p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203191703265.png" alt="image-20220319170356177" style="zoom: 50%;" /></p><ul><li><p>首先进入 <a href="https://www.tidio.com/">Tidio 官网</a>进行注册，可能需要魔法上网</p></li><li><p>选择live chat 在settings 中调整自己的语句和外观</p></li><li><p>在setting-&gt;developver中复制public key</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203191711294.png" alt="image-20220319171101114" style="zoom: 50%;" /></p></li><li><p>在主题的配置文件中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Tidio online chat</span><br><span class="hljs-attr">tidio:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">key:</span> <span class="hljs-string">your</span> <span class="hljs-string">public</span> <span class="hljs-string">key</span><br></code></pre></td></tr></table></figure></li><li><p>更改主题文件</p><p>/hexo-theme-fluid/layout_partials/footer.ejs中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;!-- 在线通讯Tidio --&gt;<br>&lt;% if (theme.tidio.enable)&#123; %&gt;<br>&lt;script src=&quot;//code.tidio.co/your_public_key.js&quot;&gt;&lt;/script&gt;<br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure></li><li><p>重新部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算小于等于N的质数的并行算法</title>
    <link href="/2022/03/17/%E8%AE%A1%E7%AE%97%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8EN%E7%9A%84%E8%B4%A8%E6%95%B0%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/17/%E8%AE%A1%E7%AE%97%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8EN%E7%9A%84%E8%B4%A8%E6%95%B0%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="遍历每一个数判断是否是质数">1. 遍历每一个数，判断是否是质数</h2><h3 id="朴素方法-是否可以被整除">朴素方法 是否可以被整除</h3><p>我们判断<spanclass="math inline">\(N\)</span>是否是质数时，不选要考虑<spanclass="math inline">\(\leq N\)</span>的所有情况,只需要考虑<spanclass="math inline">\(N\)</span>是否可以被小于等于<spanclass="math inline">\(\sqrt{N}\)</span>的数整除就可以了，因此代码如下(此时不考虑并行情况)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ifprime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= <span class="hljs-built_in">sqrt</span>(n); k++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n % k == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPrime</span><span class="hljs-params">(vector&lt;<span class="hljs-type">long</span>&gt; &amp;prime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= SIZE; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ifprime(i))<br>            prime.<span class="hljs-built_in">emplace_back</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">long</span>&gt; prime;<br>    <span class="hljs-type">double</span> t = <span class="hljs-built_in">omp_get_wtime</span>();<br>    <span class="hljs-comment">// add your codes begin</span><br>    <span class="hljs-built_in">getPrime</span>(prime);<br>    <span class="hljs-comment">// add your codes end</span><br>    t = <span class="hljs-built_in">omp_get_wtime</span>() - t;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;time %f %ld\n&quot;</span>, t, <span class="hljs-built_in">long</span>(SIZE));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nsize %ld\n&quot;</span>, prime.<span class="hljs-built_in">size</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此时运行时间为</strong></p><blockquote><p>time=0.477831</p></blockquote><p>时间后的1000000时参数SIZE，含义是<span class="math inline">\(\leq1000000\)</span>中有78498个质数</p><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203171647230.png"alt="image-20220317164726164" /><figcaption aria-hidden="true">image-20220317164726164</figcaption></figure><p>而在使用openmp并行后，从2-SIZE，每个线程分配一部分，判断是否为质数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ifprime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= <span class="hljs-built_in">sqrt</span>(n); k++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n % k == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPrime</span><span class="hljs-params">(vector&lt;<span class="hljs-type">long</span>&gt; &amp;prime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 并行的写入vector</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec_private;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for nowait schedule(static)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= SIZE; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ifprime(i))<br>                vec_private.<span class="hljs-built_in">emplace_back</span>(i);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical</span><br>        prime.<span class="hljs-built_in">insert</span>(prime.<span class="hljs-built_in">end</span>(), vec_private.<span class="hljs-built_in">begin</span>(), vec_private.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此时运行时间为</strong></p><blockquote><p>time=0.033235</p></blockquote><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203171651834.png"alt="image-20220317165100782" /><figcaption aria-hidden="true">image-20220317165100782</figcaption></figure><h3 id="优化判断质数函数">优化判断质数函数</h3><p>首先，我们应该知道一个关于质数分布的规律：<strong>大于等于5的质数一定和6的倍数相邻</strong>。例如5和7，11和13,17和19,<strong>反之是不一定成立的</strong></p><p>证明：令x≥1，将大于等于5的自然数表示如下：···6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ···</p><p>可以看到，不和6的倍数相邻的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。因此在5到<spanclass="math inline">\(\sqrt{n}\)</span>中每6个数只判断2个，时间复杂度O(<spanclass="math inline">\(\frac{\sqrt{n}}{3}\)</span>),C++代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ifprime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">6</span> != <span class="hljs-number">1</span> &amp;&amp; n % <span class="hljs-number">6</span> != <span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">5</span>; k &lt;= <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(n)); k += <span class="hljs-number">6</span>)<br>        <span class="hljs-keyword">if</span> (n % k == <span class="hljs-number">0</span> || n % (k + <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>串行 <strong>此时运行时间为</strong></p><blockquote><p>time=0.156363</p></blockquote><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203171659060.png"alt="image-20220317165924026" /><figcaption aria-hidden="true">image-20220317165924026</figcaption></figure><p>并行 <strong>此时运行时间为</strong></p><blockquote><p>time=0.015401</p></blockquote><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203171713716.png"alt="image-20220317171312687" /><figcaption aria-hidden="true">image-20220317171312687</figcaption></figure><h2 id="使用筛法">2. 使用筛法</h2><p>我们可以标记所有合数，然后求质数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">long</span> sign[SIZE + <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPrime</span><span class="hljs-params">(vector&lt;<span class="hljs-type">long</span>&gt; &amp;prime)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> N = <span class="hljs-built_in">sqrt</span>(SIZE);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (!sign[i])<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= SIZE / i; j++)<br>        sign[i * j] = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>sign[i]=true表示i为合数，当一个数i是质数时，我们标记<spanclass="math inline">\(i*j\)</span>为合数，<spanclass="math inline">\(i*j\leq SIZE\)</span></p><h3 id="串行">串行</h3><p><strong>此时运行时间为</strong></p><blockquote><p>time=0.021131</p></blockquote><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203171712942.png"alt="image-20220317171255886" /><figcaption aria-hidden="true">image-20220317171255886</figcaption></figure><h3 id="在遍历时并行">在遍历时并行</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-type">int</span> N = <span class="hljs-built_in">sqrt</span>(SIZE);<br>  <span class="hljs-comment">// 并行的使用筛法找出所有合数</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for num_threads(NUM_THREADS)</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (!sign[i])<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= SIZE / i; j++)<br>        sign[i * j] = <span class="hljs-literal">true</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>此时运行时间为</strong></p><blockquote><p>time=0.012204</p></blockquote><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203171716363.png"alt="image-20220317171656304" /><figcaption aria-hidden="true">image-20220317171656304</figcaption></figure><h3 id="在寻找合数时并行">在寻找合数时并行</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-type">int</span> N = <span class="hljs-built_in">sqrt</span>(SIZE);<br><span class="hljs-comment">// 并行的使用筛法找出所有合数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (!sign[i])<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for num_threads(NUM_THREADS)</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= SIZE / i; j++)<br>        sign[i * j] = <span class="hljs-literal">true</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>此时运行时间为</strong></p><blockquote><p>time=0.006109</p></blockquote><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203171718941.png"alt="image-20220317171841884" /><figcaption aria-hidden="true">image-20220317171841884</figcaption></figure><h2 id="时间对比">3. 时间对比</h2><table><thead><tr class="header"><th>方法</th><th>时间</th></tr></thead><tbody><tr class="odd"><td>朴素方法 串行</td><td>0.477831</td></tr><tr class="even"><td>朴素方法 并行</td><td>0.033235</td></tr><tr class="odd"><td>优化判断质数 串行</td><td>0.156363</td></tr><tr class="even"><td>优化判断质数 并行</td><td>0.015401</td></tr><tr class="odd"><td>筛法 串行</td><td>0.021131</td></tr><tr class="even"><td>筛法 遍历时并行</td><td>0.012204</td></tr><tr class="odd"><td>筛法 寻找合数时并行</td><td>0.006109</td></tr></tbody></table><h2 id="多线程写入vector">4. 多线程写入vector</h2><p>在完成上述问题时，遇到过循环中多线程无法对同一个vector进行写操作，有以下几种解决方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec_private;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for nowait <span class="hljs-comment">//fill vec_private in parallel</span></span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>        vec_private.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical</span><br>    vec.<span class="hljs-built_in">insert</span>(vec.<span class="hljs-built_in">end</span>(), vec_private.<span class="hljs-built_in">begin</span>(), vec_private.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>OpenMP 4.0允许使用reduction</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp declare reduction (merge : std::vector<span class="hljs-string">&lt;int&gt;</span> : omp_out.insert(omp_out.end(), omp_in.begin(), omp_in.end()))</span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for reduction(merge: vec)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) <br>    vec.<span class="hljs-built_in">push_back</span>(i);<br></code></pre></td></tr></table></figure><p>较为详细的可以这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel</span><br>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec_private;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for nowait schedule(static)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123; <br>        vec_private.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp for schedule(static) ordered</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">omp_get_num_threads</span>(); i++) &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp ordered</span><br>        vec.<span class="hljs-built_in">insert</span>(vec.<span class="hljs-built_in">end</span>(), vec_private.<span class="hljs-built_in">begin</span>(), vec_private.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>并行计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算作业1</title>
    <link href="/2022/03/13/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A1/"/>
    <url>/2022/03/13/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A1/</url>
    
    <content type="html"><![CDATA[<h2id="一云使能技术主要包括哪些技术组件简要说明其关键特征">一、云使能技术主要包括哪些技术组件？简要说明其关键特征。</h2><h4 id="数据中心技术">1. 数据中心技术</h4><p>一种特殊的IT基础设施，用于集中放置IT资源，包括服务器、数据库、网络与通信设备以及软件系统。数据中心是全球协作的特定设备网络，用来在因特网上传递、加速、展示、计算、存储数据信息。数据中心大部分电子元件都是由低直流电源驱动运行的。数据中心的产生致使人们的认识从定量、结构的世界进入到不确定和非结构的世界中，它将和交通、网络通讯一样逐渐成为现代社会基础设施的一部分，进而对很多产业都产生了积极影响。不过数据中心的发展不能仅凭经验，还要真正的结合实践，促使数据中心发挥真正的价值作用，促使社会的快速变革。</p><h3 id="虚拟化技术">2. 虚拟化技术</h3><p>是将物理IT资源转换为虚拟IT资源的过程，虚拟服务器使用自己的客户操作系统，独立于创建虚拟服务器的操作系统，在虚拟服务器上运行的客户操作系统和应用软件，都不会感知到虚拟化的过程。</p><h3 id="web技术">3. web技术</h3><p>Web是一种典型的分布式应用结构。Web应用中的每一次信息交换都要涉及客户端和服务端。因此，Web开发技术大体上也可以被分为客户端技术和服务端技术两大类。Web客户端的主要任务是展现信息内容。Web客户端设计技术主要包括HTML语言、JavaApplets、脚本程序、CSS、DHTML、插件技术以及VRML技术。与Web客户端技术从静态向动态的演进过程类似，Web服务端的开发技术也是由静态向动态逐渐发展、完善起来的。Web服务器技术主要包括服务器、CGI、PHP、ASP、ASP.NET、Servlet和JSP技术。</p><h3 id="多租户技术">4. 多租户技术</h3><p>多租户简单来说是指一个单独的实例可以为多个组织服务。多租户技术为共用的数据中心内如何以单一系统架构与服务提供多数客户端相同甚至可定制化的服务，并且仍然可以保障客户的数据隔离。一个支持多租户技术的系统需要在设计上对它的数据和配置进行虚拟分区，从而使系统的每个租户或称组织都能够使用一个单独的系统实例，并且每个租户都可以根据自己的需求对租用的系统实例进行个性化配置。多租户技术可以实现多个租户之间共享系统实例，同时又可以实现租户的系统实例的个性化定制。通过使用多租户技术可以保证系统共性的部分被共享，个性的部分被单独隔离。通过在多个租户之间的资源复用，运营管理维护资源，有效节省开发应用的成本。而且，在租户之间共享应用程序的单个实例，可以实现当应用程序升级时，所有租户可以同时升级。同时，因为多个租户共享一份系统的核心代码，因此当系统升级时，只需要升级相同的核心代码即可。</p><h3 id="服务技术">5. 服务技术</h3><p>基于Web的服务(如Web服务和REST服务)依靠非专有通信和技术接口定义来建立基于Web技术的标准通信框架，服务代理提供事件驱动运行时处理，适用于云中大量的功能。许多代理都自动部署在操作系统和基于云的产品中，服务中间件(如ESB和业务流程平台)可以在云上部署。</p><h2id="二列举至少3种虚拟化软件并概括其特点">二、列举至少3种虚拟化软件，并概括其特点。</h2><ul><li><p>VMware ESXi侧重于服务器虚拟化，技术较成熟，功能也多，支持虚机系统多。</p></li><li><p>Xenserver重点在于桌面虚拟化，性价比高，网络性能好，适用于快速与大规模部署，支持系统也相对较多。</p></li><li><p>Hype-V 微软开发，起步相对较晚，对于MS的系统较为支持。</p></li><li><p>Oracle VM VirtualBox 开源，支持的系统种类繁多。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云计算</tag>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将hexo源码上传github</title>
    <link href="/2022/03/11/%E5%B0%86hexo%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0github/"/>
    <url>/2022/03/11/%E5%B0%86hexo%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0github/</url>
    
    <content type="html"><![CDATA[<p>在将博客部署在github后，因为仓库的默认分支中存储的是静态html，而不是源码，所以在重新部署时会非常麻烦，需要重新配置。因为本身是一个喜欢折腾的人，为了防止某一天环境搞乱后追悔莫及，也为了方便查看配置文件更改了什么内容，所以使用版本控制是十分必要的。（额。。每个主题config不同，而我未来换主题的次数可能有辣么一点点多。)</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112113312.png" alt="image-20220311211359269" style="zoom:50%;" /></p><p>网上的教程挺多的，但是有点过程十分繁琐而且没有必要。在尝试后，我总结了相对简单的步骤，使用vscode进行图形化git操作，因为我身边的大部分人可能只会git clone</p><h3 id="新建分支">1. 新建分支</h3><p>一般来说，hexo生成的静态html文件都保存在master分支，我们需要新建一个分支用来存储源代码，我新建了source分支</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112044392.png" style="zoom:50%;" /></p><p>然后把source设置为默认分支</p><p><strong>Settings-&gt;Branches-&gt;Default branches</strong></p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112047709.png" alt="image-20220311204717670" style="zoom: 67%;" /></p><h3 id="本地操作">2. 本地操作</h3><p>将仓库克隆到本地，使用vscode打开，左下角应该显示source分支</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112051236.png" alt="image-20220311205109210" style="zoom:80%;" /></p><p>把里边的东西删掉，因为source是从master clone过来的静态html我们并不需要这些东西，保留.git文件夹</p><p>然后将你的hexo文件夹下的所有内容复制到该文件下(执行hexo clean &amp; g&amp;s 的目录) 如果主题是clone下来的，删除主题文件夹下的.git文件夹</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112054538.png" alt="image-20220311205410479" style="zoom: 67%;" /></p><p>一般来说在初始化会自己有.gitignore文件，没有的话就自己新建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">.DS_Store<br>Thumbs.db<br>db.json<br>*.log<br>node_modules/<br>public/<br>.deploy*/<br>_multiconfig.yml<br></code></pre></td></tr></table></figure><p>这样的目的是把无关的内容去掉，因为我们只需要config以及博客.md，npm依赖包和生成的静态html我们并不需要</p><p>再次确定<strong>博客是部署在非source分支</strong>，一般在_config.yml文件下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">https://github.com/username/username.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h3 id="推送">3. 推送</h3><p>将更改提交，并且推送到github</p><p><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112104237.png" /></p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112106897.png" alt="image-20220311210640855" style="zoom:67%;" /></p><p>这时我们就成功了，在本地做更改时，我们会将更改的config文件和md文件推送到source分支</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112109311.png" alt="image-20220311210901157" style="zoom: 33%;" /></p><p>而执行hexo d 会部署在master分支</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112110969.png" alt="image-20220311211024886" style="zoom:40%;" /><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203112110060.png" alt="image-20220311211049948" style="zoom:40%;" /></p><p>至此我们的目的就达到了，这样在弄些花里胡哨的东西时就不用担心出现错误无法回退了。</p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>准备考研有感</title>
    <link href="/2022/03/11/%E5%87%86%E5%A4%87%E8%80%83%E7%A0%94%E6%9C%89%E6%84%9F/"/>
    <url>/2022/03/11/%E5%87%86%E5%A4%87%E8%80%83%E7%A0%94%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="之前">之前</h3><p>基本上大家对学习的态度，你拉着我走，我也不想走：</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203111547111.png" alt="image-20220311154655943" style="zoom: 33%;" /></p><h3 id="现在">现在</h3><p>上课到处都是拿着考研书籍的人，图书馆也都是熟人，这让躺在床上的我很难啊</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203111549187.png" alt="image-20220311154907145" style="zoom: 67%;" /></p><p>争取努力努力，拼搏9个月，我要有学上 <span class="github-emoji"data-alias="muscle" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4aa.png?v8">💪</span></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/09/hello-world/"/>
    <url>/2022/03/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 笔记</title>
    <link href="/2022/03/08/LeetCode-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/08/LeetCode-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="两数之和">1. 两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案 <imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203021820930.png"alt="image-20220302182050779" /></p><p>链接：https://leetcode-cn.com/problems/two-sum</p><h3 id="解法">解法：</h3><p>常规思路是使用两个for循环，遍历数组中的组合方式，返回满足结果的答案；</p><p>时间复杂度是<span class="math inline">\(O(n^2)\)</span>;</p><p>核心代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numslength; i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; numslength; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(nums[i]+nums[j]==target &amp;&amp; i!=j)<br>        &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(i);<br>            res.<span class="hljs-built_in">emplace_back</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种解法，使用map数据结构，&lt;key,value&gt;=&lt;nums[i],index&gt;;遍历数组，使用count();计算target-nums[i]的个数，使用map在<spanclass="math inline">\(O(1)\)</span>的时间复杂度内找到taget-nums[i]的index;</p><p>因为count()函数时间复杂度为<span class="math inline">\(O(\log^{n})\)</span>,总的时间复杂度为<spanclass="math inline">\(O(n\log{n})\)</span>;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; M;<br>    <span class="hljs-type">int</span> numslength = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numslength;++i)&#123;<br>        M.<span class="hljs-built_in">insert</span>(&#123;nums[i], i&#125;);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numslength;++i)<br>    &#123;<br>        <span class="hljs-type">int</span> numsOfOther = M.<span class="hljs-built_in">count</span>(target - nums[i]);<br>        <span class="hljs-keyword">if</span>(numsOfOther&gt;<span class="hljs-number">0</span>&amp;&amp;(M[target - nums[i]]!=i))&#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(i);<br>            res.<span class="hljs-built_in">emplace_back</span>(M[target - nums[i]]);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两数相加">2.两数相加</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203021937657.png"alt="image-20220302193756590" />链接：https://leetcode-cn.com/problems/add-two-numbers</p><h3 id="解题">解题</h3><p>难点在于返回的是一个指针</p><p>建立一个头节点，使用while循环，遍历两个数组，对应数字相加，mod10放入新链表，、10与下一组累加；同时在循环外判断最后一个数在/10是否大于0，如果大于0，新加一个节点；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x, ListNode *next) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function">ListNode *<span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode *l1, ListNode *l2)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    ListNode *prehead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    ListNode *cur = prehead;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l1 || l2)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (l1)<br>            t += l1-&gt;val, l1 = l1-&gt;next;<br>        <span class="hljs-keyword">if</span> (l2)<br>            t += l2-&gt;val, l2 = l2-&gt;next;  <span class="hljs-comment">// 一般情况下 t += (A[i] + B[i])后是一个0-19大的数字，个位push到当前位，而十位只有0和1作为进位继续后面的加法</span><br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>); <span class="hljs-comment">// t % 10 是 t的个位</span><br>        cur = cur-&gt;next;<br>        t /= <span class="hljs-number">10</span>; <span class="hljs-comment">// t/=10，计算是否有进位，并更新t, 在下一轮继续 t += (A[i] + B[i])</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (t)<br>    &#123;<br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t);<br>    &#125; <span class="hljs-comment">// 别忘了如果最后一位加法完成后，还得考虑进位</span><br>    <span class="hljs-keyword">return</span> prehead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无重复字符的最长字串">3. 无重复字符的最长字串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong> 的长度。</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203021951814.png" alt="image-20220302195158780" style="zoom:100%;" /></p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203021952737.png" alt="image-20220302195217708" style="zoom: 80%;" /></p><h3 id="解题-1">解题：</h3><p>使用滑动数组解决</p><p>定义一个数组numOfCha用来记录每种字母与空格的数量，定义leftIndex标记子串的左界</p><p>使用for循环遍历字符串：如果遍历到的字符已出现次数为0,子串向右加一，numOfCha更新，计算长度(i-letIndex+1)，更新最大长度；否则不断弹出最左侧的字符，leftIndex++,相当于向右滑动；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> leftIndex=<span class="hljs-number">0</span>, maxLength=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> numOfCha[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">memset</span>(numOfCha, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(numOfCha));<br>    set&lt;<span class="hljs-type">char</span>&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len;i++)<br>    &#123;<br>      <span class="hljs-keyword">while</span> (numOfCha[s[i]-<span class="hljs-string">&#x27; &#x27;</span>]!=<span class="hljs-number">0</span>)<br>      &#123;<br>          numOfCha[s[leftIndex] - <span class="hljs-string">&#x27; &#x27;</span>]--;<br>          leftIndex++;<br>      &#125;<br>      maxLength = <span class="hljs-built_in">max</span>(maxLength, i - leftIndex + <span class="hljs-number">1</span>);<br>      numOfCha[s[i] - <span class="hljs-string">&#x27; &#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxLength;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长回文子串">5. 最长回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code>中最长的回文子串</p><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203022141480.png"alt="image-20220302214119440" /><figcaption aria-hidden="true">image-20220302214119440</figcaption></figure><h3 id="解法-1">解法：</h3><ul><li><p>扩展中心</p><p>我们知道字符串一定是对称的，所以我们可以每次循环的时候选择一个中心，进行左右扩展，判断新扩展的字符是否相等。</p><figure><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203041856092.png"alt="image-20220304185620795" /><figcaption aria-hidden="true">image-20220304185620795</figcaption></figure><p>因为存在奇数的字符串或者偶数的字符串，所以我们需要从一个字符开始扩展，或者两个连续的字符开始扩展，所以共有n+ (n-1)个中心。</p><p>时间复杂度：O(<span class="math inline">\(n^2\)</span>）O(<spanclass="math inline">\(n^2\)</span>）。</p><p>空间复杂度：O(1）O(1）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">expendAroundCenter</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> lef, <span class="hljs-type">int</span> rig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> subLef = lef;<br>    <span class="hljs-type">int</span> subRig = rig;<br>    <span class="hljs-comment">// 左界应该在大于等于0，右界应当小于字符串的长度，同时新扩展的两个字符应当相等</span><br>    <span class="hljs-keyword">while</span> ((subLef &gt;= <span class="hljs-number">0</span>) &amp;&amp; (subRig &lt; s.<span class="hljs-built_in">length</span>()) &amp;&amp; (s[subLef] == s[subRig]))<br>    &#123;<br>        subLef--;<br>        subRig++;<br>    &#125;<br>    <span class="hljs-comment">//返回的是以s[lef,rig]为中心的回文子串长度</span><br>    <span class="hljs-keyword">return</span> subRig - subLef + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//主函数</span><br><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//如果S是空，则返回空</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;&quot;</span> || s.<span class="hljs-built_in">length</span>() &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//用来标记最长回文子串的左右界</span><br>    <span class="hljs-type">int</span> strStart = <span class="hljs-number">0</span>, strEnd = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> strLen = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-comment">//遍历每一个字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strLen; i++)<br>    &#123;<br>        <span class="hljs-comment">//以该字符为中心，或者连续两个字符为中心</span><br>        <span class="hljs-type">int</span> len1 = <span class="hljs-built_in">expendAroundCenter</span>(s, i, i);<br>        <span class="hljs-type">int</span> len2 = <span class="hljs-built_in">expendAroundCenter</span>(s, i, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(len1, len2);<br>        <span class="hljs-comment">//如果长度大于我们标记的，更新左右界</span><br>        <span class="hljs-keyword">if</span> (len &gt; strEnd - strStart + <span class="hljs-number">1</span>)<br>        &#123;<br>            strStart = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            strEnd = i + len / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(strStart, strEnd - strStart + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="字符串转整数">8. 字符串转整数</h2><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32位有符号整数（类似 C/C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><ol type="1"><li>读入字符串并丢弃无用的前导空格</li><li>读入下一个字符，确定正负号，若不存在假定为正</li><li>读入数字转化为整数，无数字则为0</li><li>若溢出int,则截断整数</li></ol><hr /><p>输入: s=“ -42 akkk”</p><p>输出: -42</p><p>输入: s="-2147483648"</p><p>输出: -2147483648</p><p>输入: s=“ 2147483648”</p><p>输出: 2147483648</p><p>链接：https://leetcode-cn.com/problems/string-to-integer-atoi</p><h3 id="解法-2">解法：</h3><p>思路较为清晰和明确，整体是遍历一遍字符串</p><p>首先去除开头的空格，index++;</p><p>如果index==len,全是空格，则返回0；</p><p>之后判断正负，使用sign标定</p><p>转化数字时因为只能使用32位，所以判断时应该与INT_MAX/10比较，因为INT数字范围是<spanclass="math inline">\(\left[ -2^{32},2^{32}-1\right]\)</span>，所以在判断个位数时应该使用大于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>, sign = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//如果是空格，索引向后</span><br>    <span class="hljs-keyword">while</span> (s[index] == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; index &lt; len)<br>    &#123;<br>        index++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index == len)<br>    &#123; <span class="hljs-comment">//整个字符串都是空格</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[index] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        &#123; <span class="hljs-comment">//是否为负数</span><br>            sign = <span class="hljs-number">-1</span>;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[index] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>        &#123; <span class="hljs-comment">//是否为正数</span><br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (index &lt; len &amp;&amp; s[index] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; s[index] &gt;= <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> curDigit = s[index] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (res &gt; INT_MAX / <span class="hljs-number">10</span> || ((res == INT_MAX / <span class="hljs-number">10</span>) &amp;&amp; (curDigit &gt; INT_MAX % <span class="hljs-number">10</span>)))<br>            &#123;<br>                <span class="hljs-keyword">return</span> sign==<span class="hljs-number">1</span>?INT_MAX:INT_MIN;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res = res * <span class="hljs-number">10</span> + curDigit;<br>            &#125;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sign * res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长公共前缀">14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>""</code></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/F7kyyy/picture@main/img/202203151519386.png"alt="image-20220315151908284" /><figcaption aria-hidden="true">image-20220315151908284</figcaption></figure><p>题目链接：https://leetcode-cn.com/problems/longest-common-prefix/</p><h4 id="解法-3">解法：</h4><h5 id="暴力">1. 暴力</h5><p>首先，我们可以找到最短串的长度minStrLen，这样在比较每个字母是就不用担心会溢出</p><p>然后，遍历每个字符串，当同一index的字母相同时，res加上该字母，否则break</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>       string res = <span class="hljs-string">&quot;&quot;</span>;<br>       <span class="hljs-type">int</span> minStrLen = <span class="hljs-number">300</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-built_in">size</span>(); i++)<br>       &#123;<br>           <span class="hljs-type">int</span> indexLen = strs[i].<span class="hljs-built_in">size</span>();<br>           <span class="hljs-keyword">if</span> (indexLen &lt; minStrLen)<br>           &#123;<br>               minStrLen = indexLen;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; minStrLen; i++)<br>       &#123;<br>           <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; strs.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j++)<br>           &#123;<br>               <span class="hljs-keyword">if</span>(strs[j][i]!=strs[j+<span class="hljs-number">1</span>][i])<br>               &#123;<br>                   flag = <span class="hljs-literal">false</span>;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(flag)<br>               res += strs[<span class="hljs-number">0</span>][i];<br>           <span class="hljs-keyword">else</span><br>               <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的结果为</p><h5 id="image-20220315161954911"><imgsrc="https://cdn.jsdelivr.net/gh/F7kyyy/picture@main/img/202203151619970.png"alt="image-20220315161954911" /></h5><h5 id="字典序排序">2. 字典序排序</h5><p>在对字符串进行sort时，是按照字典序，所以我们完全可以在排序后比较第一个和最后一个的公共前缀子串，这样就可以省去比较每一个字符串的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt; &amp;strs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(strs.<span class="hljs-built_in">begin</span>(), strs.<span class="hljs-built_in">end</span>());<br>    string res;<br>    string first = strs.<span class="hljs-built_in">front</span>();<br>    string end = strs.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; first.<span class="hljs-built_in">size</span>() &amp;&amp; i &lt; end.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(first[i]!=end[i])&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        res += first[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/F7kyyy/picture@main/img/202203151624701.png"alt="image-20220315162405643" /><figcaption aria-hidden="true">image-20220315162405643</figcaption></figure><p>这样极大的缩短了代码量，大佬们的脑洞太大了</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算实验1-使用github,hexo搭建个人博客</title>
    <link href="/2022/03/08/%E9%85%8D%E7%BD%AEhexo/"/>
    <url>/2022/03/08/%E9%85%8D%E7%BD%AEhexo/</url>
    
    <content type="html"><![CDATA[<h1 id="山东大学-计算机科学与技术-学院-云计算技术-课程实验报告">山东大学计算机科学与技术 学院 云计算技术 课程实验报告</h1><h2 id="姓名学号">1. 姓名学号</h2><p>201900130128 冯子恺 数据19</p><h2 id="实验题目">2. 实验题目</h2><p>Github + Hexo搭建个人博客系统</p><h2 id="实验目的">3. 实验目的</h2><p>熟悉个人博客系统的搭建</p><h2 id="实验环境">4. 实验环境</h2><ul><li><p>硬件环境</p><p>Intel Core I5-8300H</p><p>Nvidia Geforce gtx1060</p></li><li><p>软件环境</p><p>Windows10 21H2</p></li></ul><h2 id="实验步骤与内容">5. 实验步骤与内容</h2><h3 id="注册github账号下载gitnode">5.1注册github账号，下载git，node</h3><p>之前已经做过，而且较为简单，这里不再重复</p><h3 id="新建一个仓库">5.2 新建一个仓库</h3><p>新建一个公共仓库，作为博客的部署的位置</p><h3 id="配置ssh-key">5.3 配置ssh key</h3><p>由于椭圆加密相同密钥长度下，安全性能更高同时计算量小，处理速度快，在私钥的处理速度上比RSA快的多，所以在生成密钥对时，使用ECC加密</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> ecdsa<br></code></pre></td></tr></table></figure><p>将公钥上传到github,测试连接</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh <span class="hljs-literal">-T</span> git@github.com<br></code></pre></td></tr></table></figure><p>连接成功</p><p><imgsrc="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203072016135.png" /></p><h3 id="配置hexo">5.4 配置hexo</h3><ul><li>安装hexo</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo<br></code></pre></td></tr></table></figure><ul><li>新建一个文件夹,初始化博客</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure><ul><li>安装依赖包，确保git部署</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>此时本地已经配置好博客</p><p>使用命令启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br>hexo s<br></code></pre></td></tr></table></figure><h3 id="更换主题">5.5 更换主题</h3><p>依据个人喜好更换主题，这里使用Aurora</p><h3 id="博客部署在github.io">5.6 博客部署在github.io</h3><ul><li><p>复制SSH链接</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203072023291.png" alt="" style="zoom: 80%;" /></p></li><li><p>编辑 config_yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:Fantastic-Feng/Fantastic-Feng.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li><li><p>配置Deploy keys</p><p>与SSH配置方法相同，存在bug，添加后不显示，不过可以使用</p></li><li><p>部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br>hexo d<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203072028743.png" alt="" style="zoom:50%;" /></p></li></ul><h3 id="访问">5.7 访问</h3><p>https://f7kyyy.github.io/</p><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203072031185.png" alt="" style="zoom: 50%;" /></p><h3 id="添加一篇博客">5.7 添加一篇博客</h3><p>生成一个新的md文件，在 ./source/_posts文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;new article&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g     //生成静态页面<br>hexo s    //启动本地服务器进行查看<br>hexo d   //查看后没有问题即可部署到github上<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Fantastic-Feng/picgo/raw/master/202203072055102.png" alt="" style="zoom:50%;" /></p><h2 id="结论分析与体会">6. 结论分析与体会</h2><p>网络上程序员好像人手一个博客，之前想过用java 和vue自己实现一个博客项目，太麻烦了就一直没弄</p><p>hexo还是比较方便的，同时有各种主题可以选择，还是很不错的</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>云计算</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
